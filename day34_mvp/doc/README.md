# day34

### MVC 举例

M: model， V: View，C：controller

1. MVC 两个地方：个人主页，编辑资料，MVC意味着加载个人信息等这些代码是需要写很多份
2. 如果团队协作，多人开发，那么这个页面（编辑资料）一般都是一个人在做，项目比较紧凑的时候，不好分配人
3. 如果某些界面需求变更的情况下，不好定位，或者说出了 Bug 的情况下不怎么好修改（代码多）

### MVP 举例

M: Model 数据层，访问网络数据都写在这里面
V: View 界面层，与 View 相关的一些操作都写在这里面，Activity , Fragment , ViewGroup 
P: Presenter 解耦关联层（Model - View），可能还有一些额外的逻辑：数据的一些处理逻辑

### MVC 和 MVP 对比分析

不好地方：

1. 接口回调超级多；
2. 类会增多，逻辑看上去似乎复杂了

好的地方：

1. 如果哪个部分出了问题方便修改，比如说如果只是界面的一些调整方便修改V层（后期维护）
2. 方便多人协作，V，M，P 
3. 业务逻辑复用性强 （大型）

### 泛型构建基类
    
问题分析：

1. simple2问题:每次都写这么多代码很麻烦, 例如解绑问题 -> 模板基类 + 泛型
2. simple3问题:每次都需要去判断 View != null ,这个也很麻烦，怎么办怎么办？ -> 解决办法:利用AOP思想(AspectJ/动态代理)将判空统一处理

### 每天一个点

GC标记/回收算法

https://www.cnblogs.com/sunfie/p/5125283.html

前面看不懂太多，首先还是要把基础体系建立。   JVM平台不一样可能 GC 回收有区别，好比 Andoroid 3.0 和 4.0 

对象什么时候回收？ 对象有没有死掉？ 2种算法（判断对象需不需要回收）1. 引用计数法 ，2. GcRoot 可达分析算法

回收算法： 判断死了，回收（回收算法）  分为两步 （需要回收的对象加入队列，调用对象的 finalize 方法） 
1. 标记清楚算法（效率低，节省一些内存）
2. 复制算法 （效率要高，浪费一些内存）
3. 标记整理算法
4. 分代算法 
涉及GC 分带年龄，对象有年龄  新生代，老年代，永久代。 Class 头信息 

### 动态代理优化,防止每次使用都要判空

1. 每次都需要去判断 View != null ,这个也很麻烦，怎么办怎么办？
2. 都是接口 ，通用代码 View != null 统一处理，这个是 AOP (aspectJ,动态代理)

### 动态创建 P 和 M

多 Presenter 和多 Model 思考

通过注入的方式,动态创建
或者通过dagger来处理

### 静态代理封装通用 

适配不同的UI组件

### 后续其他扩展   数据恢复，界面显示优化（Loading ,NetError,DataError）, Dagger 注入，参考 MVPArms

改抛异常的就抛异常,不然用户会懵逼
考虑使用JetPack

### 代码架构和运行时架构（内涵段子）

代码架构：与业务逻辑无关，基本上每个项目都要用的，比如访问，网络，图片，Activity，Fragment 等等 (一般是不会变动，多下些功夫)
运行时架构：与业务逻辑有关，是这个项目特有的一些功能部分，比如，参数要加密（RSA）单点登录，插件换肤等等（BaseSkinActivity）

### 怎么选择架构层级

1. 所有代码，写在一起也就是都在 app 里面 （外包，一个人做）
2. 按架构层级分层  Base , FrameWorker , App , 每个层次一个模块  （内涵段子）
3. 多模块和多组件开发 （协同，多人开发，方便测试），注意的是不用用蜘蛛网，最好用路由的方式
      什么是模块什么是组件 ?  
        模块更多的是你的项目的功能模块，例如首页/发现/我的
        组件一般都是一些小型的辅助（例如网络组件,第三方的自定义View，第三方的一些基础功能）（也可以单独存在于moudle中）
      处理不好还是会有一些问题的，资源问题，命名不能冲突，针对问题要不断调整？分析经验，我带大家解决问题的方式，解决问题能力

### 个人能力

目前工作能力 60 
解决问题能力 60
学习能力     20

### 怎么选择第三方库

1. 熟悉原理（比较重要）开发可控
2. 选择大多数人选择（国外），GitHub上面的问题都解决没？是否停止更新 ，可以依赖多个第三方
3. 要注意尽量添加解耦层（为了以后重构，版本迭代）
4. 要站在成员的角度去选择（可以通过培训或者倒逼成员去学习） 
5. 学习模仿自己实现,等等

### 其他的补充

1. 关于需求文档（吃了很多亏，多反思）,可以自己写需求分析文档（画UML/流程图等）
2. 不要滥用继承和接口,继承深度越深出错率越高. 多用封装(哪怕是工具类)， Retrofit 封装好用，但是比较死，深度定制的问题（出错率就会大，代码的可读性就会弱） 版本迭代功能扩展比较致命
3. 不要嵌套（直接依赖,编译更换）（内涵端子，每个功能部分都是分开的） 
4. 问题的解决方式多种，找最简单的 （《墨菲定律》）

### 知识方面

数据结构和算法
自定义View
系统源码
设计模式和第三方库源码

https://www.jianshu.com/p/883c584fdedc