# day34

### MVC 举例

M: model， V: View，C：controller

1. MVC 两个地方：个人主页，编辑资料，MVC意味着加载个人信息等这些代码是需要写很多份
2. 如果团队协作，多人开发，那么这个页面（编辑资料）一般都是一个人在做，项目比较紧凑的时候，不好分配人
3. 如果某些界面需求变更的情况下，不好定位，或者说出了 Bug 的情况下不怎么好修改（代码多）

### MVP 举例

M: Model 数据层，访问网络数据都写在这里面
V: View 界面层，与 View 相关的一些操作都写在这里面，Activity , Fragment , ViewGroup 
P: Presenter 解耦关联层（Model - View），可能还有一些额外的逻辑：数据的一些处理逻辑

### MVC 和 MVP 对比分析

不好地方：

1. 接口回调超级多；
2. 类会增多，逻辑看上去似乎复杂了

好的地方：

1. 如果哪个部分出了问题方便修改，比如说如果只是界面的一些调整方便修改V层（后期维护）
2. 方便多人协作，V，M，P 
3. 业务逻辑复用性强 （大型）

### 泛型构建基类
    
问题分析：

1. simple2问题:每次都写这么多代码很麻烦, 例如解绑问题 -> 模板基类 + 泛型
2. simple3问题:每次都需要去判断 View != null ,这个也很麻烦，怎么办怎么办？ -> 解决办法:利用AOP思想(AspectJ/动态代理)将判空统一处理

### 每天一个点

GC标记/回收算法

https://www.cnblogs.com/sunfie/p/5125283.html

前面看不懂太多，首先还是要把基础体系建立。   JVM平台不一样可能 GC 回收有区别，好比 Andoroid 3.0 和 4.0 

对象什么时候回收？ 对象有没有死掉？ 2种算法（判断对象需不需要回收）1. 引用计数法 ，2. GcRoot 可达分析算法

回收算法： 判断死了，回收（回收算法）  分为两步 （需要回收的对象加入队列，调用对象的 finalize 方法） 
1. 标记清楚算法（效率低，节省一些内存）
2. 复制算法 （效率要高，浪费一些内存）
3. 标记整理算法
4. 分代算法 
涉及GC 分带年龄，对象有年龄  新生代，老年代，永久代。 Class 头信息 

### 动态代理优化,防止每次使用都要判空

1. 每次都需要去判断 View != null ,这个也很麻烦，怎么办怎么办？
2. 都是接口 ，通用代码 View != null 统一处理，这个是 AOP (aspectJ,动态代理)

### 动态创建 P 和 M

多 Presenter 和多 Model 思考

通过注入的方式,动态创建
或者通过dagger来处理

### 静态代理封装通用 

适配不同的UI组件

### 后续其他扩展   数据恢复，界面显示优化（Loading ,NetError,DataError）, Dagger 注入，参考 MVPArms

考虑使用JetPack